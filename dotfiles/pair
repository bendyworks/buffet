#!/usr/bin/env bash

function pair {

local pair_file="$HOME/.pairrc"



# STATIC TEXT =================================================================

local generated_heading="\
# This file is automatically generated by the pair() function found in ~/.pair"

local usage_short="\
pair --help
pair --unpair
pair [--domain <domain>] [--prefix <prefix>] username1 [username2...]"

local err_no_users="\
\033[0;31mERROR:\033[0m no Github usernames were supplied; usage:
$usage_short"



# HELPER FUNCTIONS ============================================================

function _pair_show_usage_long {
  cat <<USAGE | less
pair - Git author pairing
=========================

A convenient script for setting the current Git repository's user.name and
user.email to the collective Github names and emails of the listed
participants.

IMPORTANT: This requires that the user source the ".pairrc" file in their home
directory.

Usage
-----

$1

Arguments
---------

pair
  Display the current pair information.

username1 [username2...]
  Sets the following environment variables:

  - GIT_AUTHOR_NAME and GIT_COMMITTER_NAME to
    "<username1's name> + <username2's name>"

  - GIT_AUTHOR_EMAIL and GIT_COMMITTER_EMAIL to
    "<PAIR_EMAIL_PREFIX>+username1+username2@<PAIR_EMAIL_DOMAIN>"

  If only a single username is supplied, then their Github name and email will
  be used in the Git settings.

-d (--domain)
  Sets the domain of "user.email" to the given domain. The domain is not
  checked for accuracy; this is left to the user.

-h (--help)
  Displays this help text.

-p (--prefix)
  Sets the prefix (everything before the email comments containing the
  usernames) of "user.email" to the given prefix.

-u (--unpair)
  Sets "user.name" and "user.email" as blank.

USAGE
}

function _pair_err_invalid_option {
  echo -e "\033[0;31mERROR:\033[0m invalid option \"$1\"; usage:
$usage_short"
  return 1
}

function _pair_err_missing_arg {
  echo -e "\033[0;31mERROR:\033[0m missing argument to option \"$1\"; usage:
$usage_short"
  return 1
}

function _pair_unset {
  cat <<UNPAIR > "$pair_file"
$generated_heading

unset GIT_AUTHOR_NAME
unset GIT_AUTHOR_EMAIL
unset GIT_COMMITTER_NAME
unset GIT_COMMITTER_EMAIL
UNPAIR
}

function _pair_set {
  cat <<PAIR > "$pair_file"
$generated_heading

export GIT_AUTHOR_NAME="$1"
export GIT_AUTHOR_EMAIL="$2"
export GIT_COMMITTER_NAME="$1"
export GIT_COMMITTER_EMAIL="$2"
PAIR
}

function _pair_name_for {
  echo "$(curl -is https://api.github.com/users/$1 | \
    grep -o '"name":.*"' | \
    cut -d \" -f 4)"
}

function _pair_warn_no_github_name {
  echo -e "\033[0;33mWARNING:\033[0m No Github name found for user \"$1\""
}



# SCRIPT ======================================================================

local opt_email_domain opt_email_prefix opt_unpair  # function options
local domain name prefix users                      # used in for loops
local pair_email pair_name usernames                # crafting the pair values

# Parse options and arguments, including getting the list of usernames to pair

usernames=()

while [ $# -gt 0 ] ; do
  case "$1" in
    '-h' | '--help'   ) _pair_show_usage_long "$usage_short"                                    ; return 0 ;;
    '-u' | '--unpair' ) opt_unpair="true"                                                       ; break    ;;
    '-d' | '--domain' ) if [[ -n "$2" ]] ; then
                          opt_email_domain=$2
                        else
                          echo -e "$(_pair_err_missing_arg "$1")"
                          return 1
                        fi                                                                      ; shift 2  ;;
    '-p' | '--prefix' ) if [[ -n "$2" ]] ; then
                          opt_email_prefix=$2
                        else
                          echo -e "$(_pair_err_missing_arg "$1")"
                          return 1
                        fi                                                                      ; shift 2  ;;
    -*                ) echo -e "$(_pair_err_invalid_option "$1")" >&2                             ; return 1 ;;
    *                 ) usernames+=("$1")                                                       ; shift 1  ;;
  esac
done

if [[ -n "$opt_unpair" ]]; then
  _pair_unset
  pair_name="$(git config user.name)"
  pair_email="$(git config user.email)"
else



  # Error if no usernames are supplied

  if [[ -z "${usernames[0]}" ]]; then
    echo -e "$err_no_users"
    return 1
  fi



  # Generate the pairing name

  for user in ${usernames[*]}; do
    name="$(_pair_name_for "$user")"

    if [[ -z "$name" ]] ; then
      echo -e "$(_pair_warn_no_github_name "$user")"
      name="$user"
    fi

    [[ -n "$pair_name" ]] && name=" + $name" || name="$name"
    pair_name="$pair_name$name"
  done



  # Generate the pairing email address

  for prefix in 'dev' "$PAIR_EMAIL_PREFIX" "$opt_email_prefix"; do
    [[ -n "$prefix" ]] && email_prefix="$prefix"
  done

  for domain in 'bendyworks.com' "$PAIR_EMAIL_DOMAIN" "$opt_email_domain"; do
    [[ -n "$domain" ]] && email_domain="$domain"
  done

  pair_email="$email_prefix"
  for user in ${usernames[*]}; do
    pair_email="$pair_email+$user"
  done
  pair_email="$pair_email@$email_domain"



  # Export the pair names as config vars

  _pair_set "$pair_name" "$pair_email"
fi



# SUCCESS =====================================================================

. "$pair_file"
echo -e "\033[0;32mSUCCESS:\033[0m $pair_name <$pair_email>"
return 0
}











#  set_session_vars() {
#    [[ ! -f "$HOME/.pairrc" ]] || source "$HOME/.pairrc"
#  }
#
#  print_config() {
#    set_session_vars
#    [[ -n "$GIT_AUTHOR_NAME" ]] && name="$GIT_AUTHOR_NAME" || name=$(git config user.name)
#    [[ -n "$GIT_AUTHOR_EMAIL" ]] && email="$GIT_AUTHOR_EMAIL" || email=$(git config user.email)
#    echo "user.name  = $name"
#    echo "user.email = $email"
#  }
#
#  case "x$1" in
#  x-u) echo "unset GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL" > "$HOME/.pairrc"
#       print_config
#       return 0
#       ;;
#  x-q) set_session_vars
#       return 0
#       ;;
#  x-h | x--help)
#       echo "Usage: pair [option] | [username...]"
#       echo "Examples:"
#       echo "  pair rylnd mathias     Sets git author to "Matt Gauger and Ryland Herrick""
#       echo "  pair                   Lists current author/email"
#       echo "Options:"
#       echo "  -u                     Unsets author/email"
#       echo "  -h, --help             Prints this lovely message"
#       return 0
#       ;;
#  x-*) echo "Unknown option: '$1'"
#       return 1
#       ;;
#  esac
#
#  usernames=($(printf "%s\n" $@ | tr A-Z a-z | sort))
#
#  if [[ -z "$usernames" ]]; then
#    print_config
#    return 0
#  fi
#
#  for user in ${usernames[@]}; do
#    if [[ -z "$(eval echo \$$user)" ]]; then # user cache MISS, check GitHub
#      name=$(curl -is https://api.github.com/users/$user | grep -o '"name":.*"' | cut -d \" -f 4)
#
#      if [[ -z "$name" ]]; then
#        echo "No author name found for GitHub username: $user."
#        echo "Are you online, and does their GitHub profile have a name?"
#        return 1
#      else
#        local $user="$name"
#      fi
#    fi
#    names=(${names[@]} \$$user)
#    pair_email=$pair_email+$user
#  done
#
#  pair_email=$PAIR_EMAIL_USERNAME$pair_email@$PAIR_EMAIL_DOMAIN
#
#  if [[ ${#names[@]} > 2 ]]; then
#    pair_name=$(printf "%s, " "${names[@]}")
#    pair_name="$(eval echo $pair_name)"
#    pair_name=$(echo "$pair_name" | sed 's/,\([^,]*\),$/, and\1/')
#  else
#    pair_name=$(printf "%s and " "${names[@]}")
#    pair_name="$(eval echo $pair_name)"
#    pair_name=$(echo "$pair_name" | sed 's/ and$//')
#  fi
#
#  echo "export GIT_AUTHOR_NAME=\"$pair_name\" GIT_AUTHOR_EMAIL=\"$pair_email\"" > "$HOME/.pairrc"
#  print_config
#}
